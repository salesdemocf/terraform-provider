apiVersion: tf.upbound.io/v1beta1
kind: Workspace
metadata:
  name: sample-workspace
spec:
  providerConfigRef:
    name: aws-irsa
  forProvider:
    source: Inline
    module: |
      resource "aws_vpc" "main" {
        cidr_block = "10.20.0.0/16"

        tags = {
          Name = "${var.eks_cluster_name}"
        }
      }
      resource "aws_subnet" "main1" {
        vpc_id     = aws_vpc.main.id
        cidr_block = "10.20.10.0/24"

        tags = {
          Name = "${var.eks_cluster_name}"
        }
      }

      resource "aws_subnet" "main2" {
        vpc_id     = aws_vpc.main.id
        cidr_block = "10.20.11.0/24"

        tags = {
          Name = "${var.eks_cluster_name}"
        }
      }

      resource "aws_iam_role" "main" {
        name = "${var.eks_cluster_name}"

        assume_role_policy = jsonencode({
          Statement = [{
            Action = "sts:AssumeRole"
            Effect = "Allow"
            Principal = {
              Service = "ec2.amazonaws.com"
            }
          }]
          Version = "2012-10-17"
        })
      }

      resource "aws_iam_role_policy_attachment" "main-AmazonEKSWorkerNodePolicy" {
        policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
        role       = aws_iam_role.main.name
      }

      resource "aws_iam_role_policy_attachment" "main-AmazonEKS_CNI_Policy" {
        policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
        role       = aws_iam_role.main.name
      }

      resource "aws_iam_role_policy_attachment" "main-AmazonEC2ContainerRegistryReadOnly" {
        policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
        role       = aws_iam_role.main.name
      }

      resource "aws_eks_cluster" "main" {
        name    = "${var.eks_cluster_name}"
        role_arn = aws_iam_role.main.arn

        vpc_config {
          endpoint_public_access  = true
          subnet_ids = [aws_subnet.main1.id, aws_subnet.main2.id]
        }

        access_config {
          authentication_mode                         = "CONFIG_MAP"
          bootstrap_cluster_creator_admin_permissions = true
        }
      }

      resource "aws_eks_addon" "coredns" {
        cluster_name                = aws_eks_cluster.main.name
        addon_name                  = "coredns"
        resolve_conflicts_on_create = "OVERWRITE"
      }

      resource "aws_eks_addon" "kube-proxy" {
        cluster_name                = aws_eks_cluster.main.name
        addon_name                  = "kube-proxy"
        resolve_conflicts_on_create = "OVERWRITE"
      }

      resource "aws_eks_addon" "vpc-cni" {
        cluster_name                = aws_eks_cluster.main.name
        addon_name                  = "vpc-cni"
        resolve_conflicts_on_create = "OVERWRITE"
      }

      resource "aws_eks_node_group" "main" {
        cluster_name    = aws_eks_cluster.main.name
        node_group_name = aws_eks_cluster.main.name
        node_role_arn   = aws_iam_role.main.arn
        subnet_ids      = aws_subnet.main[*].id
        instance_types = ["t3.large"]

        scaling_config {
          desired_size = 1
          max_size     = 2
          min_size     = 1
        }

        update_config {
          max_unavailable = 1
        }

        depends_on = [
          aws_iam_role_policy_attachment.main-AmazonEKSWorkerNodePolicy,
          aws_iam_role_policy_attachment.main-AmazonEKS_CNI_Policy,
          aws_iam_role_policy_attachment.main-AmazonEC2ContainerRegistryReadOnly
        ]
      }
      variable "eks_cluster_name" {
        description = "EKS Cluster Name"
        type        = string
      }
    vars:
      - key: eks_cluster_name
        value: "codefresh-demo-environment"
